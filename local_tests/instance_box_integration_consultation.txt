Nyashãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®InstanceBoxçµ±ä¸€Factoryè¨­è¨ˆã«ã¤ã„ã¦æ·±ã„æŠ€è¡“ç›¸è«‡

ã€èƒŒæ™¯ã€‘
Phase 9.78: çµ±åˆBoxFactoryã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å®Ÿè£…ä¸­
- âœ… å®Œäº†: ãƒ“ãƒ«ãƒˆã‚¤ãƒ³Boxçµ±åˆï¼ˆStringBox, IntegerBoxç­‰ï¼‰
- ğŸ¯ ç¾åœ¨: ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©Boxçµ±åˆè¨­è¨ˆæ¤œè¨ä¸­
- ç›®æ¨™: ã€Œãƒ•ãƒ­ãƒ¼ã®ä¸Šã§ã¯ã™ã¹ã¦åŒã˜ã€çµ±ä¸€ç¾å­¦ã®å®Ÿç¾

ã€ç¾åœ¨ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€‘
```rust
// çµ±ä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
pub trait BoxFactory: Send + Sync {
    fn create_box(&self, name: &str, args: &[Box<dyn NyashBox>]) -> Result<Box<dyn NyashBox>, RuntimeError>;
    fn box_types(&self) -> Vec<&str>;
}

// çµ±ä¸€ãƒ¬ã‚¸ã‚¹ãƒˆãƒª
pub struct UnifiedBoxRegistry {
    factories: Vec<Arc<dyn BoxFactory>>,  // å„ªå…ˆé †: builtin > user > plugin
    type_cache: RwLock<HashMap<String, usize>>,
}
```

ã€è¨­è¨ˆç›®æ¨™ã€‘
```rust
// ã™ã¹ã¦åŒã˜ãƒ•ãƒ­ãƒ¼ - Everything is Boxå“²å­¦ã®å®Ÿè£…ãƒ¬ãƒ™ãƒ«ä½“ç¾
registry.create_box("StringBox", args)    // â†’ BuiltinBoxFactory
registry.create_box("FileBox", args)      // â†’ PluginBoxFactory  
registry.create_box("MyUserBox", args)    // â†’ UserDefinedBoxFactory
```

ã€è¨­è¨ˆå€™è£œæ¯”è¼ƒæ¤œè¨ã€‘

## **Option A: å‹•çš„Factoryç™»éŒ²æˆ¦ç•¥ï¼ˆè¤‡æ•°Factoryè²¬å‹™åˆ†é›¢ï¼‰**

**1. UserDefinedBoxFactoryè¨­è¨ˆ:**
```rust
pub struct UserDefinedBoxFactory {
    interpreter_ref: Weak<RefCell<NyashInterpreter>>, // å¾ªç’°å‚ç…§å›é¿
    registered_types: RwLock<HashSet<String>>,        // å‹•çš„ç™»éŒ²æ¸ˆã¿å‹ç®¡ç†
}

impl BoxFactory for UserDefinedBoxFactory {
    fn create_box(&self, name: &str, args: &[Box<dyn NyashBox>]) -> Result<Box<dyn NyashBox>, RuntimeError> {
        // 1ï¸âƒ£ boxå®£è¨€å–å¾—
        let interpreter = self.interpreter_ref.upgrade().ok_or(...)?;
        let box_decl = interpreter.borrow().get_box_declaration(name)?;
        
        // 2ï¸âƒ£ InstanceBoxä½œæˆï¼ˆæ—¢å­˜InstanceBoxå®Œå…¨æ´»ç”¨ï¼‰
        let mut instance = InstanceBox::new(name, box_decl);
        
        // 3ï¸âƒ£ ç¶™æ‰¿ãƒã‚§ãƒ¼ãƒ³å‡¦ç†ï¼ˆfrom Parentçµ±åˆï¼‰
        if let Some(parent) = &box_decl.parent {
            self.handle_delegation_chain(&mut instance, parent, args)?;
        }
        
        // 4ï¸âƒ£ birth/pack/initãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ï¼ˆæ—¢å­˜ãƒ•ãƒ­ãƒ¼å®Œå…¨æ´»ç”¨ï¼‰
        self.execute_constructor(&mut instance, args)?;
        
        // 5ï¸âƒ£ çµ±ä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§è¿”å´
        Ok(Box::new(instance))
    }
}
```

**2. å‹•çš„ç™»éŒ²ã‚·ã‚¹ãƒ†ãƒ :**
```rust
impl NyashInterpreter {
    fn execute_box_declaration(&mut self, decl: &BoxDeclaration) {
        // boxå®£è¨€ã®ä¿å­˜
        self.register_box_declaration(decl.name.clone(), decl.clone());
        
        // çµ±åˆãƒ¬ã‚¸ã‚¹ãƒˆãƒªã«å‹•çš„ç™»éŒ²
        let registry = get_global_unified_registry();
        registry.lock().unwrap().register_user_defined_type(decl.name.clone());
    }
    
    pub fn get_box_declaration(&self, name: &str) -> Option<&BoxDeclaration> {
        self.box_declarations.get(name)
    }
}
```

**3. çµ±åˆãƒ¬ã‚¸ã‚¹ãƒˆãƒªæ‹¡å¼µ:**
```rust
impl UnifiedBoxRegistry {
    pub fn register_user_defined_type(&mut self, type_name: String) {
        // UserDefinedBoxFactoryã«å‹è¿½åŠ ã‚’é€šçŸ¥
        if let Some(user_factory) = self.get_user_defined_factory() {
            user_factory.add_type(type_name);
        }
    }
}
```

**Option A ãƒ¡ãƒªãƒƒãƒˆ:**
1. **è²¬å‹™åˆ†é›¢**: å„Factoryå†…ã§é©åˆ‡ãªå®Ÿè£…ï¼ˆãƒ“ãƒ«ãƒˆã‚¤ãƒ³=ç›´æ¥ç”Ÿæˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼=InstanceBoxã€ãƒ—ãƒ©ã‚°ã‚¤ãƒ³=FFIï¼‰
2. **æ‹¡å¼µæ€§**: æ–°Factoryç¨®åˆ¥ã®è¿½åŠ ãŒå®¹æ˜“
3. **æ—¢å­˜æ´»ç”¨**: InstanceBoxã€birth/pack/initã€ç¶™æ‰¿ã‚·ã‚¹ãƒ†ãƒ ã‚’éƒ¨åˆ†å†åˆ©ç”¨

**Option A èª²é¡Œ:**
1. **å¾ªç’°å‚ç…§**: Factoryâ†’Interpreterâ†’Registryâ†’Factory ã®è¤‡é›‘ãªä¾å­˜é–¢ä¿‚
2. **ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ **: Weakå‚ç…§ã§ã®interpreter_refç®¡ç†ã®è¤‡é›‘æ€§
3. **å‹•çš„ç™»éŒ²**: boxå®£è¨€è§£ææ™‚ã®å‹•çš„å‹ç™»éŒ²ã®è¤‡é›‘æ€§

## **Option B: InstanceBoxçµ±ä¸€Factoryæˆ¦ç•¥ï¼ˆå˜ä¸€Factoryå®Œå…¨çµ±ä¸€ï¼‰**

```rust
/// ã™ã¹ã¦ã®Boxå‹ã‚’InstanceBoxã¨ã—ã¦çµ±ä¸€å‡¦ç†
pub struct UnifiedInstanceBoxFactory {
    builtin_registry: HashMap<String, BuiltinCreator>,
    interpreter_context: Option<Weak<RefCell<NyashInterpreter>>>,
}

impl BoxFactory for UnifiedInstanceBoxFactory {
    fn create_box(&self, name: &str, args: &[Box<dyn NyashBox>]) -> Result<Box<dyn NyashBox>, RuntimeError> {
        match self.determine_box_type(name) {
            BoxType::Builtin => {
                // ãƒ“ãƒ«ãƒˆã‚¤ãƒ³Boxã‚‚InstanceBoxã§ãƒ©ãƒƒãƒ—ã—ã¦çµ±ä¸€
                let builtin_box = self.create_builtin_box(name, args)?;
                Ok(Box::new(InstanceBox::from_builtin(builtin_box)))
            },
            BoxType::UserDefined => {
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©Boxã‚’InstanceBoxã¨ã—ã¦ä½œæˆ
                let declaration = self.get_user_box_declaration(name)?;
                Ok(Box::new(InstanceBox::from_declaration(declaration, args)?))
            },
            BoxType::Plugin => {
                // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³Boxã‚‚InstanceBoxã§ãƒ©ãƒƒãƒ—
                let plugin_box = self.create_plugin_box(name, args)?;
                Ok(Box::new(InstanceBox::from_plugin(plugin_box)))
            }
        }
    }
}

impl InstanceBox {
    /// ãƒ“ãƒ«ãƒˆã‚¤ãƒ³Boxã‹ã‚‰InstanceBoxä½œæˆ
    pub fn from_builtin(builtin: Box<dyn NyashBox>) -> Self {
        Self {
            box_type_name: builtin.type_name().to_string(),
            inner_value: Some(builtin),
            fields: HashMap::new(),
            methods: HashMap::new(),
            // ... çµ±ä¸€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
        }
    }
    
    /// ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©å®£è¨€ã‹ã‚‰InstanceBoxä½œæˆ  
    pub fn from_declaration(decl: &BoxDeclaration, args: &[Box<dyn NyashBox>]) -> Result<Self, RuntimeError> {
        let mut instance = Self::new(&decl.name);
        
        // 1. ç¶™æ‰¿ãƒã‚§ãƒ¼ãƒ³å‡¦ç†
        if let Some(parent) = &decl.parent {
            instance.setup_delegation_chain(parent)?;
        }
        
        // 2. ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆæœŸåŒ–
        for field in &decl.init_fields {
            instance.fields.insert(field.clone(), Box::new(NullBox::new()));
        }
        
        // 3. ãƒ¡ã‚½ãƒƒãƒ‰ç™»éŒ²
        for method in &decl.methods {
            instance.methods.insert(method.name.clone(), method.clone());
        }
        
        // 4. birth/pack/initã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å®Ÿè¡Œ
        instance.execute_constructor(args)?;
        
        Ok(instance)
    }
    
    /// ãƒ—ãƒ©ã‚°ã‚¤ãƒ³Boxã‹ã‚‰InstanceBoxä½œæˆ
    pub fn from_plugin(plugin: Box<dyn NyashBox>) -> Self {
        Self {
            box_type_name: plugin.type_name().to_string(),
            inner_value: Some(plugin),
            plugin_wrapped: true,
            // ... çµ±ä¸€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
        }
    }
}
```

**Option B ãƒ¡ãƒªãƒƒãƒˆ:**
1. **å®Œå…¨çµ±ä¸€**: ã™ã¹ã¦ã®Boxå‹ãŒåŒã˜InstanceBoxçµŒç”±ã§å‡¦ç†ã•ã‚Œã‚‹
2. **Everything is Box**: å“²å­¦ã«æœ€ã‚‚å¿ å®Ÿãªå®Ÿè£…
3. **å˜ç´”æ€§**: 1ã¤ã®Factoryã§ã™ã¹ã¦å‡¦ç†ã€ç†è§£ã—ã‚„ã™ã„
4. **ä¸€è²«æ€§**: ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ãƒ»ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒå®Œå…¨ã«åŒã˜ãƒ•ãƒ­ãƒ¼
5. **æ‹¡å¼µæ€§**: æ–°Boxç¨®åˆ¥ã‚‚åŒã˜InstanceBoxãƒ‘ã‚¿ãƒ¼ãƒ³

**Option B èª²é¡Œ:**
1. **InstanceBoxè‚¥å¤§åŒ–**: ã™ã¹ã¦ã‚’æ‰±ã†ãŸã‚è¤‡é›‘ã«ãªã‚‹å¯èƒ½æ€§
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: ãƒ“ãƒ«ãƒˆã‚¤ãƒ³Boxã‚‚ãƒ©ãƒƒãƒ—ã™ã‚‹ã“ã¨ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰
3. **æ—¢å­˜äº’æ›**: ç¾åœ¨ã®InstanceBoxå®Ÿè£…ã¨ã®æ•´åˆæ€§

ã€æ·±ã„æ¯”è¼ƒè³ªå•ã€‘
1. **è¨­è¨ˆå“²å­¦**: Option Aã¨Option Bã€ã©ã¡ã‚‰ãŒNyashã®ã€ŒEverything is Boxã€å“²å­¦ã«ã‚ˆã‚Šé©åˆã—ã¾ã™ã‹ï¼Ÿ
2. **å®Ÿè£…è¤‡é›‘æ€§**: å¾ªç’°å‚ç…§ã‚’æŒã¤Option Aã¨ã€InstanceBoxçµ±ä¸€ã®Option Bã€ã©ã¡ã‚‰ãŒä¿å®ˆã—ã‚„ã™ã„ã§ã™ã‹ï¼Ÿ
3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: Option Bã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³Boxãƒ©ãƒƒãƒ”ãƒ³ã‚°ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¯è¨±å®¹ç¯„å›²ã§ã™ã‹ï¼Ÿ
4. **æ‹¡å¼µæ€§**: å°†æ¥ã®æ–°Boxç¨®åˆ¥è¿½åŠ ã«ãŠã„ã¦ã€ã©ã¡ã‚‰ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒæŸ”è»Ÿã§ã™ã‹ï¼Ÿ
5. **æ—¢å­˜äº’æ›**: ç¾åœ¨ã®InstanceBoxå®Ÿè£…ã¨æœ€ã‚‚æ•´åˆæ€§ãŒå–ã‚Œã‚‹ã®ã¯ã©ã¡ã‚‰ã§ã™ã‹ï¼Ÿ
6. **ã‚³ãƒ¼ãƒ‰ã®ç¾ã—ã•**: ã€Œä¸Šã‹ã‚‰ãƒ•ãƒ­ãƒ¼ãŒç¶ºéº—ã«åˆ†ã‹ã‚Œã‚‹ã€è¦³ç‚¹ã§ã©ã¡ã‚‰ãŒå„ªã‚Œã¦ã„ã¾ã™ã‹ï¼Ÿ
7. **ä»–ã®é¸æŠè‚¢**: ã“ã‚Œã‚‰ä»¥å¤–ã«ã•ã‚‰ã«å„ªã‚ŒãŸç¬¬ä¸‰ã®è¨­è¨ˆã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ

ã€ç‰¹ã«é‡è¦ãªåˆ¤æ–­ãƒã‚¤ãƒ³ãƒˆã€‘
- Option Aã¯ã€Œè²¬å‹™åˆ†é›¢ã€ã‚’é‡è¦–ï¼ˆå„Factoryå°‚é–€åŒ–ï¼‰
- Option Bã¯ã€Œçµ±ä¸€æ€§ã€ã‚’é‡è¦–ï¼ˆã™ã¹ã¦InstanceBoxçµŒç”±ï¼‰
- ã©ã¡ã‚‰ãŒNyashã®é•·æœŸçš„ãªè¨­è¨ˆã«ã‚ˆã‚Šé©åˆã™ã‚‹ã‹ï¼Ÿ

ã€Nyashã®è¨­è¨ˆå“²å­¦ã€‘
- Everything is Box: ã™ã¹ã¦ãŒBoxã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
- æ˜ç¤ºæ€§é‡è¦–: éš ã‚ŒãŸé­”æ³•çš„å‹•ä½œã‚’é¿ã‘ã‚‹
- å®‰å…¨æ€§å„ªå…ˆ: Rustå®Ÿè£…ã«ã‚ˆã‚‹ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§
- çµ±ä¸€æ€§é‡è¦–: ä¸€è²«ã—ãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨­è¨ˆ

å°‚é–€çš„ãªè¦–ç‚¹ã‹ã‚‰ã€ã“ã®è¨­è¨ˆã®å¦¥å½“æ€§ã¨æ”¹å–„ç‚¹ã«ã¤ã„ã¦è©³ç´°ã«åˆ†æã—ã¦ãã ã•ã„ã€‚
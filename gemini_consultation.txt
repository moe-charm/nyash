Nyashプログラミング言語のビルド時間改善について深い技術相談です。

【背景と問題】
Nyashは「Everything is Box」哲学のRust製言語で、現在16個のビルトインBox（StringBox, IntegerBox, ConsoleBox, P2PBox等）が静的リンクされています。
問題：
- cargo buildに2分以上（wasmtime等の巨大依存を含む）
- 新Box追加のたびに全体再コンパイル
- バイナリサイズ15MB
- 開発効率が著しく低下

【革新的提案：動的ライブラリ分離アーキテクチャ】
すでに実装済みのFFI-ABI/ExternCall機構を活用し、ビルトインBoxを動的ライブラリ化する。

1. **nyash-core（2MB）**
   - インタープリター本体
   - 基本型のみ（String/Integer/Bool）
   - ExternCallディスパッチャー
   - FFI-ABIランタイム

2. **プラグイン構成**
   - libnyash_io.so: FileBox, ConsoleBox
   - libnyash_web.so: CanvasBox, WebDisplayBox  
   - libnyash_p2p.so: P2PBox, IntentBox
   - libnyash_math.so: MathBox, RandomBox

3. **統一インターフェース**
   ```rust
   // すでにあるExternCall命令を活用
   ExternCall { iface: "env.file", method: "read", args: [...] }
   ```
   - WASM: RuntimeImports経由
   - VM: スタブ実装
   - ネイティブ: 動的ライブラリ呼び出し
   - インタープリター: 直接実行（NEW!）

【技術的検討事項】

1. **Rust動的ライブラリ設計**
   - ABI安定性: `#[repr(C)]`使用？それともstable ABI crate？
   - libloading vs dlopen2 vs abi_stable？
   - プラグイン発見機構（ディレクトリスキャン vs 明示的登録）

2. **インターフェース設計**
   ```rust
   // Option A: C ABI
   #[no_mangle]
   extern "C" fn nyash_file_read(path: *const c_char) -> *mut c_char

   // Option B: Rust trait object
   trait NyashPlugin {
       fn get_methods(&self) -> &'static [(&'static str, MethodPtr)];
   }
   ```

3. **メモリ管理**
   - 文字列の所有権: 誰がfreeする？
   - Box<dyn NyashBox>の境界越え
   - Arc<RwLock>の共有は可能？

4. **段階的移行戦略**
   Phase 1: インタープリターでExternCall直接実行（MIR不要）
   Phase 2: FileBox/ConsoleBoxを最初のプラグインに
   Phase 3: 残りのBoxも順次移行
   Phase 4: wasmtime依存をオプショナルに

5. **クロスプラットフォーム**
   - Windows: .dll + __declspec(dllexport)
   - macOS: .dylib + 特殊リンカーフラグ
   - Linux: .so + RTLD_LAZY
   - パス解決とセキュリティ

【期待される成果】
- ビルド時間: 120秒 → 15秒（8倍高速化）
- バイナリ: 15MB → 2MB（コア部分のみ）  
- 開発効率: Box単位で独立ビルド・テスト
- 配布: 必要なBoxだけ選択的ロード

【質問】
1. Rustで最も安定した動的ライブラリ実装方法は？
2. abi_stable crateは本番環境で信頼できるか？
3. プラグイン間の依存関係管理のベストプラクティスは？
4. セキュリティ（信頼できないプラグイン）の考慮は必要か？
5. 実装の落とし穴や注意点は？

Everything is Box哲学を維持しつつ、モジュラーで高速なビルドを実現したいです。実装経験に基づいた具体的なアドバイスをお願いします。
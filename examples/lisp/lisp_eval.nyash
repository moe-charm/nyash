// âš™ï¸ LISP Evaluator - eval/apply/ç’°å¢ƒç®¡ç†
// ç°¡æ˜“ç‰ˆLISPè©•ä¾¡ã‚¨ãƒ³ã‚¸ãƒ³

NIL = 0

// ===== LISP Coreé–¢æ•°ã®å†å®Ÿè£…ï¼ˆç°¡å˜ç‰ˆï¼‰ =====
box ConsBox {
    car, cdr
    init { car, cdr }
    ConsBox(a, d) { 
        me.car = a
        me.cdr = d
    }
    getCar() { return me.car }
    getCdr() { return me.cdr }
    toString() { return "(" + me.car.toString() + " . " + me.cdr.toString() + ")" }
}

box SymbolBox {
    name
    init { name }
    SymbolBox(symbolName) { 
        me.name = symbolName 
    }
    getName() { return me.name }
    toString() { return me.name }
}

function cons(a, d) { return new ConsBox(a, d) }
function car(pair) { 
    if pair == NIL { return NIL }
    return pair.getCar() 
}
function cdr(pair) { 
    if pair == NIL { return NIL }
    return pair.getCdr() 
}
function symbol(name) { return new SymbolBox(name) }
function list1(a) { return cons(a, NIL) }
function list2(a, b) { return cons(a, cons(b, NIL)) }
function list3(a, b, c) { return cons(a, cons(b, cons(c, NIL))) }

function atomP(obj) {
    if obj == NIL { return true }
    if obj == 0 or obj == 1 or obj == 2 or obj == 3 or obj == 4 { return true }
    if obj == 5 or obj == 6 or obj == 7 or obj == 8 or obj == 9 { return true }
    if obj == "a" or obj == "b" or obj == "c" { return true }
    return false
}

function nullP(obj) { return obj == NIL }

// ===== ç°¡æ˜“ç’°å¢ƒç®¡ç†ï¼ˆMapBoxä»£æ›¿ï¼‰ =====
box Environment {
    names, values, count
    
    init { names, values, count }
    
    Environment() {
        me.names = cons(NIL, NIL)   // å¤‰æ•°åã®ãƒªã‚¹ãƒˆ
        me.values = cons(NIL, NIL)  // å€¤ã®ãƒªã‚¹ãƒˆ
        me.count = 0                // å¤‰æ•°ã®æ•°
    }
    
    // å¤‰æ•°ã‚’å®šç¾©
    define(name, value) {
        me.names = cons(name, me.names)
        me.values = cons(value, me.values)
        me.count = me.count + 1
    }
    
    // å¤‰æ•°ã‚’æ¤œç´¢
    lookup(name) {
        return me.lookupHelper(name, me.names, me.values)
    }
    
    lookupHelper(target, nameList, valueList) {
        if nullP(nameList) { return symbol("UNDEFINED") }
        
        currentName = car(nameList)
        currentValue = car(valueList)
        
        // åå‰ãŒä¸€è‡´ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        if currentName == target {
            return currentValue
        }
        if currentName.toString() == target {
            return currentValue
        }
        
        return me.lookupHelper(target, cdr(nameList), cdr(valueList))
    }
}

// ===== åŸºæœ¬çš„ãªè©•ä¾¡é–¢æ•° =====

// eval - å¼ã‚’è©•ä¾¡
function lispEval(expr, env) {
    // ã‚¢ãƒˆãƒ ã®å ´åˆ
    if atomP(expr) {
        // æ•°å€¤ã¯ãã®ã¾ã¾è¿”ã™
        if expr == 0 { return 0 }
        if expr == 1 { return 1 }
        if expr == 2 { return 2 }
        if expr == 3 { return 3 }
        if expr == 4 { return 4 }
        if expr == 5 { return 5 }
        if expr == 6 { return 6 }
        if expr == 7 { return 7 }
        if expr == 8 { return 8 }
        if expr == 9 { return 9 }
        
        // æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯ãã®ã¾ã¾è¿”ã™
        if expr == "a" { return "a" }
        if expr == "b" { return "b" }
        if expr == "c" { return "c" }
        if expr == "hello" { return "hello" }
        if expr == "world" { return "world" }
        
        // ã‚·ãƒ³ãƒœãƒ«ï¼ˆå¤‰æ•°ï¼‰ã¯ç’°å¢ƒã‹ã‚‰æ¤œç´¢
        return env.lookup(expr.toString())
    }
    
    // ãƒªã‚¹ãƒˆï¼ˆé–¢æ•°å‘¼ã³å‡ºã—ï¼‰ã®å ´åˆ
    operator = car(expr)
    operands = cdr(expr)
    
    // ç‰¹æ®Šå½¢å¼ã®å‡¦ç†
    opName = operator.toString()
    
    // quote - ãƒªãƒ†ãƒ©ãƒ«
    if opName == "quote" {
        return car(operands)
    }
    
    // if - æ¡ä»¶åˆ†å²
    if opName == "if" {
        condition = lispEval(car(operands), env)
        if not nullP(condition) {
            return lispEval(car(cdr(operands)), env)  // thenç¯€
        } else {
            return lispEval(car(cdr(cdr(operands))), env)  // elseç¯€
        }
    }
    
    // define - å¤‰æ•°å®šç¾©
    if opName == "define" {
        varName = car(operands).toString()
        value = lispEval(car(cdr(operands)), env)
        env.define(varName, value)
        return value
    }
    
    // é€šå¸¸ã®é–¢æ•°å‘¼ã³å‡ºã—
    func = lispEval(operator, env)
    args = lispEvalList(operands, env)
    return lispApply(func, args, env)
}

// å¼•æ•°ãƒªã‚¹ãƒˆã‚’è©•ä¾¡
function lispEvalList(exprs, env) {
    if nullP(exprs) { return NIL }
    first = lispEval(car(exprs), env)
    rest = lispEvalList(cdr(exprs), env)
    return cons(first, rest)
}

// apply - é–¢æ•°é©ç”¨
function lispApply(func, args, env) {
    funcName = func.toString()
    
    // çµ„ã¿è¾¼ã¿é–¢æ•°
    if funcName == "+" {
        return lispAdd(args)
    }
    if funcName == "-" {
        return lispSub(args)
    }
    if funcName == "*" {
        return lispMul(args)
    }
    if funcName == "car" {
        return car(car(args))
    }
    if funcName == "cdr" {
        return cdr(car(args))
    }
    if funcName == "cons" {
        return cons(car(args), car(cdr(args)))
    }
    if funcName == "atom?" {
        return atomP(car(args))
    }
    if funcName == "null?" {
        return nullP(car(args))
    }
    
    return symbol("UNKNOWN-FUNCTION")
}

// ç®—è¡“æ¼”ç®—ã®å®Ÿè£…
function lispAdd(args) {
    if nullP(args) { return 0 }
    return car(args) + lispAdd(cdr(args))
}

function lispSub(args) {
    if nullP(args) { return 0 }
    if nullP(cdr(args)) { return 0 - car(args) }  // å˜é …ãƒã‚¤ãƒŠã‚¹
    return car(args) - lispAdd(cdr(args))
}

function lispMul(args) {
    if nullP(args) { return 1 }
    return car(args) * lispMul(cdr(args))
}

// ===== ã‚°ãƒ­ãƒ¼ãƒãƒ«ç’°å¢ƒåˆæœŸåŒ– =====
function makeGlobalEnv() {
    env = new Environment()
    
    // çµ„ã¿è¾¼ã¿é–¢æ•°ã‚’å®šç¾©
    env.define("+", symbol("+"))
    env.define("-", symbol("-"))
    env.define("*", symbol("*"))
    env.define("car", symbol("car"))
    env.define("cdr", symbol("cdr"))
    env.define("cons", symbol("cons"))
    env.define("atom?", symbol("atom?"))
    env.define("null?", symbol("null?"))
    
    // ç‰¹æ®Šå€¤
    env.define("nil", NIL)
    env.define("t", true)
    
    return env
}

// ===== ç°¡æ˜“ãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆæ‰‹å‹•æ§‹ç¯‰ç‰ˆï¼‰ =====
function parseManual() {
    // (+ 1 2) ã‚’æ‰‹å‹•æ§‹ç¯‰
    expr1 = list3(symbol("+"), 1, 2)
    return expr1
}

// ===== ãƒ†ã‚¹ãƒˆ =====
print("âš™ï¸ === LISP Evaluator Test === âš™ï¸")
print("")

// ç’°å¢ƒæº–å‚™
globalEnv = makeGlobalEnv()

print("1. Simple arithmetic:")
// (+ 1 2)
expr = list3(symbol("+"), 1, 2)
print("   Expression: " + expr.toString())
result = lispEval(expr, globalEnv)
print("   Result: " + result)

print("")
print("2. Nested expression:")
// (+ 1 (* 2 3))
inner = list3(symbol("*"), 2, 3)
expr2 = list3(symbol("+"), 1, inner)
print("   Expression: " + expr2.toString())
result2 = lispEval(expr2, globalEnv)
print("   Result: " + result2)

print("")
print("âœ… LISP Evaluator test completed!")
print("ğŸ¯ Ready for full LISP interpreter!")
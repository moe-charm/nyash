Nyash言語のweak参照システム最終実装について技術的相談をお願いします。

【現在の状況】
copilot様がweak参照システムを99%完成させました。驚くべき実装品質です。

【✅ 完成済みの素晴らしい実装】
1. ハイブリッド構造: fields + fields_ng 併用システム
2. weak参照専用メソッド: set_weak_field(), get_weak_field()
3. 文字列ベース追跡: "WEAK_REF_TO:..." → "WEAK_REFERENCE_DROPPED"
4. インタープリター統合: weak参照の検出・代入・アクセス完璧
5. 5つの包括的テストケース

【⚠️ 残り1%の課題】
単一関数 trigger_weak_reference_invalidation() が未実装：

```rust
pub(super) fn trigger_weak_reference_invalidation(&mut self, target_info: &str) {
    eprintln!("🔗 DEBUG: Triggering global weak reference invalidation for: {}", target_info);
    
    // TODO: Real implementation would require tracking all instances 
    // and their weak references
}
```

【現在の動作】
```
✅ weak参照検出: 完璧 (🔗 DEBUG: Assigning to weak field 'parent')
✅ ドロップ検出: 動作中 (🔗 DEBUG: Variable 'parent' set to 0)
✅ 無効化呼び出し: 実行中 (🔗 DEBUG: Triggering global weak reference invalidation)
❌ 実際のnil化: 未接続 (🔗 DEBUG: Weak field 'parent' still has valid reference)
```

【copilot提案の実装アプローチ】
グローバルインスタンス追跡システム：

```rust
pub struct SharedState {
    // 既存フィールド...
    pub instance_registry: Arc<Mutex<Vec<Weak<Mutex<InstanceBox>>>>>,
}

impl SharedState {
    fn register_instance(&mut self, instance: Weak<Mutex<InstanceBox>>) { ... }
    fn invalidate_weak_references(&mut self, target_info: &str) {
        // 全インスタンスを走査してweak参照を無効化
    }
}
```

【技術的課題】
1. 全InstanceBox作成時のグローバル登録必要
2. 複雑なスレッドセーフティ管理
3. デッドweak参照のガベージコレクション
4. 5+ファイルにわたる変更

【代替案検討の観点】
1. **より簡単な実装**: グローバル追跡なしで実現可能？
2. **性能重視**: シンプルな文字列マッチングで十分？
3. **段階的実装**: デモレベルで動作する最小実装？

【具体的質問】
1. グローバルインスタンス追跡は本当に必要ですか？
2. copilotの文字列ベース追跡をより簡単に完成できますか？
3. 「target_info」による簡単なマッチング実装は可能ですか？
4. デモ目的なら手動的な実装で十分ではないですか？

【Nyashの設計哲学】
- Everything is Box: すべてがBoxオブジェクト
- 明示性重視: 隠れた動作を避ける
- シンプル重視: 初学者フレンドリー
- 実用性優先: 完璧より動くもの

プログラミング言語実装の専門的観点から、最もシンプルで実装しやすいアプローチを提案してください。copilot様の99%完成した実装を活かしつつ、最後の1%を効率的に完成させる方法をお願いします。
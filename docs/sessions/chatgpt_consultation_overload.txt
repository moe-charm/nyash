Nyashプログラミング言語の関数オーバーロード設計について深い技術的相談です。

【Nyashの技術的特徴】
- Everything is Box哲学: 全データがBoxオブジェクト
- Arc<Mutex>統一アーキテクチャ: 完全スレッドセーフ設計
- 明示性重視: 変数宣言先の即座特定可能
- Rust実装: メモリ安全性+高性能
- 目的: 初学者フレンドリー + 実用性

【検討する技術的課題】
現在P2PBox実装において、関数オーバーロード（引数数による分岐）採用の是非を検討中。

具体例：
```rust
// Option A: オーバーロードあり
impl P2PBox {
    pub fn send(&self, message: IntentBox) -> Result<(), SendError>  // ブロードキャスト
    pub fn send(&self, to: &str, message: IntentBox) -> Result<(), SendError>  // 個別送信
    pub fn send(&self, to: &str, message: IntentBox, opts: SendOpts) -> Result<(), SendError>  // オプション付き
}

// Option B: オーバーロードなし（現在）
impl P2PBox {
    pub fn broadcast(&self, message: IntentBox) -> Result<(), SendError>
    pub fn send(&self, to: &str, message: IntentBox) -> Result<(), SendError>
    pub fn send_with_options(&self, to: &str, message: IntentBox, opts: SendOpts) -> Result<(), SendError>
}
```

【技術的検討ポイント】

1. **Rust実装との整合性**
   - Rustにはメソッドオーバーロードがない
   - 引数数による分岐をインタープリターで実装する必要
   - パフォーマンスへの影響

2. **Arc<Mutex>アーキテクチャとの親和性**
   - 動的ディスパッチの複雑さ
   - エラーハンドリングの一貫性
   - スレッドセーフティの保持

3. **インタープリター実装の複雑度**
   - パーサーでの引数数判定
   - 実行時メソッド選択アルゴリズム
   - デバッグ情報の提供

4. **型安全性とパフォーマンス**
   - 実行時型チェックのオーバーヘッド
   - エラーメッセージの品質
   - 開発時デバッグ体験

5. **エコシステム設計との整合性**
   - 他のBox型との一貫性
   - 拡張性（新しいオーバーロード追加）
   - メンテナンス性

【深く検討してほしい点】
1. 技術的実装の複雑さ vs ユーザー体験の向上
2. Nyashの「明示性重視」哲学との技術的整合性
3. 初学者がエラーに遭遇した時のデバッグ体験
4. P2P通信という特定ドメインでの最適解
5. 言語の長期進化における影響

プログラミング言語実装の専門的視点から、技術的に最良で保守しやすい設計を分析してください。
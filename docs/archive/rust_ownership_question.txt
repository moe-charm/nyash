Nyashプログラミング言語のRust実装で困っています。

【現在の問題】
Everything is Box設計で、全てのデータがBox<dyn NyashBox>として管理されています。
しかし以下の3箇所で clone_box() を使って毎回新しいインスタンスを作成してしまい、
ステートフルなオブジェクト（SocketBoxなど）の状態が保持されない問題が発生しています。

【問題箇所】
1. resolve_variable() - src/interpreter/core.rs:366
```rust
let cloned_value = local_value.clone_box();  // ← 毎回新インスタンス
return Ok(cloned_value);
```

2. get_field() - src/instance.rs:275
```rust
self.fields.lock().unwrap().get(field_name).map(|v| v.clone_box())  // ← フィールド複製
```

3. execute_field_access() - src/interpreter/expressions.rs:779
```rust
let field_value = instance.get_field(field)  // ← 上記を呼び出し
```

【現在のデータ構造】
- local_vars: HashMap<String, Box<dyn NyashBox>>
- fields: Arc<Mutex<HashMap<String, Box<dyn NyashBox>>>>
- 全てのBoxは Arc<Mutex> で内部状態を管理

【症状】
me.server.bind() → SocketBox ID=10で成功、is_server=true
me.server.isServer() → SocketBox ID=19で失敗、is_server=false
毎回別インスタンスになってしまう

【質問】
Rustの所有権システムを正しく使って、clone_box()ではなく「同じBoxインスタンスへの参照」を返すにはどう実装すべきでしょうか？

考えられるアプローチ：
1. Arc<dyn NyashBox>に統一する
2. Rc<dyn NyashBox>を使う
3. 参照を返す（ライフタイム管理）
4. 他の適切なパターン

具体的なコード例を交えて、Rust的に正しい設計を教えてください。
Rustのプログラミングに関して深い技術的質問があります。

【状況】
Arc<Mutex<bool>>を使った構造体があります：

```rust
struct SocketBox {
    is_server: Arc<Mutex<bool>>,
    // ...他のフィールド
}

impl Clone for SocketBox {
    fn clone(&self) -> Self {
        Self {
            is_server: Arc::clone(&self.is_server), // 同じArcを共有
            // ...
        }
    }
}
```

【期待される動作】
- 一つのクローンで *self.is_server.lock().unwrap() = true すると
- 他のクローンでも同じArcを参照しているので true が見えるはず

【実際に起きた問題】
- bind()メソッドで is_server を true に設定
- その後 isServer()メソッドで確認すると false のまま
- Arc::clone()で同じArcインスタンスを共有しているはずなのに状態変更が見えない

【デバッグ情報】
- Arcポインタアドレスは同じ (例: 5645546739b0)
- しかしbind()後にisServer()を呼ぶと別のBox IDで実行される
- 「同じArcアドレスなのに中身がNone」のような現象も観測された

【質問】
1. Arc::clone()で共有されたMutex<bool>の状態変更が他のクローンで見えない原因は何が考えられますか？
2. RustのArc<Mutex<T>>で状態共有がうまくいかないパターンはありますか？
3. Box IDが変わることがArc共有に影響する可能性はありますか？
4. 「同じArcポインタアドレスなのに中身が変化する」現象の技術的説明は？
5. unsafe操作やメモリ破壊が関係している可能性はありますか？

【環境】
- Rust実装のインタープリター言語（Nyash）
- Everything is Box哲学でArc<Mutex<dyn NyashBox>>統一設計
- clone()時に新しいBox IDが生成される設計

Rustの所有権システムやArc/Mutexの実装レベルでの深い知識をお聞かせください。
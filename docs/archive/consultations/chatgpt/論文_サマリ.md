# Nyash: Everything is Box — 統一メモリモデルと弱参照による安全なライフサイクル管理

最終更新: 2025-08-13（ドラフト）

## 概要（Abstract）
本稿は、すべての値を統一的なコンテナ「Box」として扱う“Everything is Box”哲学に基づくプログラミング言語Nyashを提案する。Nyashは、言語構文レベルでメモリ管理を明示化し、予測可能なライフサイクル制御とメモリ安全性を両立する。具体的には、(1) Boxのフィールドは`init { ... }`で宣言し、(2) 再代入・スコープ終了・明示的破棄などの節目で`fini()`による予備解放を行い、(3) ローカル変数はスコープを抜けると自動解放、(4) 循環参照は`init { weak ... }`で弱参照を宣言して回避する。実装はRustで行い、`Arc<Mutex<...>>`と`Weak`を活用、解放済みの二重処理防止や弱参照の自動nil化を含む。設計は明示的デリゲーション（`from`）とオーバーライドの厳密化（`override`必須）と一貫し、ブラウザ/WASMを含む現代環境での直感的・堅牢な開発体験を目指す。

## 1. 背景と動機
- 既存パラダイムの課題: 手動メモリ管理は人為的錯誤に脆弱で、GCは停止時間/タイミング不確定性を招く。双方向参照（Parent↔Child、グラフ構造等）は参照カウント系でリークの温床となる。
- 目標: 言語規範でライフサイクル規約を先に定義し、生成・使用・解放の節目を明示することで、安全で予測可能なメモリ管理を提供する。あわせて、表現力（デリゲーション、静的エントリポイント、WASM連携等）を損なわない。

## 2. 設計の中核（Language Design）
### 2.1 Everything is Box
あらゆる値（整数・文字列・配列・マップ・ユーザー定義オブジェクト・ユーティリティ等）をBoxで統一する。共通の生成・表示・比較・デバッグ・解放インターフェースを持ち、型ごとの最適化は実装側で行う。

### 2.2 フィールド宣言と初期化（`init { ... }`）
- Boxの状態は`init { field1, field2, ... }`で宣言。循環参照が想定されるフィールドは`weak`修飾で弱参照にする（例: `init { weak parent }`）。
- 生成は`new`で行い、必要に応じてコンストラクタ/`pack`等で初期値を設定する（詳細は言語ガイド参照）。

### 2.3 明示的破棄フック（`fini()`）
- `fini()`はBox単位の予備解放フック。リソース解放（子Box解放、外部ハンドルclose、解除処理等）を記述できる。
- 言語実装は、(a) フィールド再代入時、(b) スコープ終了時（ローカル環境解体）、(c) 明示呼出し時に`fini()`を安全に実行し、二重実行は抑止する。

### 2.4 ローカル変数とスコープ解放
- `local`で宣言した変数はスコープ終了時に一括解放。未宣言代入はエラーとし、見落としを防止。
- Static関数における所有権移転は`outbox`で明示化できる。

### 2.5 循環参照回避（`weak`）
- `init { weak parent }`等で弱参照フィールドを宣言する。代入時に強参照を自動ダウングレードして格納し、アクセス時はupgradeを試みる。失敗時は`null`（自動nil化）を返す。
- 双方向参照（Parent↔Child、グラフ）でも参照カウントが残存せず、リークを回避できる。

### 2.6 デリゲーション（`from`）と明示的オーバーライド
- `box Child from Parent { ... }`で機能を委譲。多重デリゲーションにより複数親の機能合成をサポート。
- 親メソッド呼出しは`from Parent.method(...)`で明示。暗黙の多段チェーン解決は明示性違反として禁止。上書きは`override`必須。

### 2.7 Static Boxエントリポイント
- `static box Main { main() { ... } }`をアプリの規約化された開始点として用意。初回アクセス時に遅延初期化される。

## 3. 実装（Rustインタープリタ）
本実装はRustにより、安全・明確な所有権モデル上でインタープリタを構築する。

### 3.1 実行時値（NyashValue）
- `NyashValue`は`Integer`, `Float`, `Bool`, `String`, `Array`, `Map`, `Box(Arc<Mutex<dyn NyashBox>>)`に加え、`WeakBox(Weak<Mutex<dyn NyashBox>>)`、`Null`、`Void`等を持つ。
- 弱参照は`upgrade_weak()`で強参照化を試み、失敗時は`None`→自動nil化の契機となる（実装詳細は最適化の都合上いくつかの互換層を伴う）。

### 3.2 インスタンス（InstanceBox）
- `InstanceBox`は（互換層の）レガシーフィールド`fields`と次世代フィールド`fields_ng`を併用。弱参照は`fields_ng`で管理し、`set_weak_field`/`get_weak_field`が自動ダウングレード/アップグレードとnil化（失敗時）を司る。
- インスタンスの`fini()`は二重呼出し防止フラグを持ち、内部フィールドのクリア等を行う。ユーザー定義`fini()`が存在すれば安全に先行実行される（インタープリタがメソッド本体を一時スタックで実行後、内部解放）。

### 3.3 予備解放（Finalization）
- `finalization`モジュールは、解放済みIDのグローバル管理とスコープ追跡（`BoxFinalizer`）を提供。スコープ終了時/再代入時にBoxを走査し、`fini()`→解放済みマーク→追跡リストクリアの順で安全に解体する。
- 代入時のふるまい: フィールドへ新しい値を設定する前に、旧値がインスタンスであれば`fini()`を呼出して二重リソース保持を回避する（ワークフローは`statements.rs`参照）。

### 3.4 構文サポート
- パーサは`init { weak ... }`を解析し、`BoxDeclaration.weak_fields`に収集。フィールドアクセス/代入時に弱参照特有のハンドリング（upgrade/nil化/ダウングレード代入）を適用する。
- Static Boxと多重デリゲーションは定義レジストリに登録され、実行時に適切な初期化・解決が行われる。

## 4. 安全性と正当性（概略）
- 予測可能な破棄点: フィールド再代入・スコープ終了・明示的呼出しといった「節目」で`fini()`が必ず実行される。
- 二重解放防止: 解放済みIDの記録により、`fini()`の多重呼出しは無害化される。
- 循環参照回避: 双方向参照を弱参照にする規約で参照カウントの残留を防止。アクセス時の自動nil化でダングリング参照も防ぐ。
- 明示性と可読性: `init`/`weak`/`from`/`override`/`local`等の構文規律により、所有権と到達可能性に関する意図をコードに刻む。

## 5. パフォーマンス特性（概略）
- weakの`upgrade()`は原子的操作＋分岐でオーバーヘッドは小さく、Mutexロックより低コストなケースが多い。
- stop-the-world GCが存在せず、解放は節目ベースで分散されるため、レイテンシ予測性が高い。
- 互換層の段階的移行（legacy→next-gen）は将来的にWeakBoxネイティブ化でさらなる最適化が可能。

## 6. 使用例
### 6.1 親子の相互参照（弱参照）
```nyash
box Parent {
    init { child }
    pack() {
        me.child = new Child()
        me.child.setParent(me)  # 循環構造だが、子側がweak参照を使用
    }
}

box Child {
    init { weak parent }
    setParent(p) { me.parent = p }  # 自動でweakに変換・格納
    getParentName() {
        if (me.parent != null) { return me.parent.getName() }
        else { return "Parent is gone" }
    }
}
```

### 6.2 再代入時の予備解放
```nyash
box Holder { init { obj } }
h = new Holder()
h.obj = new SomeBox()
h.obj = new SomeBox()  # 旧objに対してfini()が自動呼出し
```

### 6.3 Static Boxエントリ
```nyash
static box Main {
    init { console }
    main() {
        me.console = new ConsoleBox()
        me.console.log("Everything is Box!")
        return "OK"
    }
}
```

## 7. 関連研究
- SwiftのARCにおける`weak`/`unowned`参照、Rustの`Arc`/`Weak`、Pythonの`weakref`は弱参照の実務的価値を示している。本研究は、弱参照の規約化と`init`/`fini`/スコープ解放を統合した「言語仕様レベルの一貫したライフサイクル設計」を提示する点で差異化される。
- 継承ではなくデリゲーション（多重含む）を明示構文で組込むことで、暗黙の探索鎖を排し、構造的明示性とテスト容易性を高める。

## 8. 制限と今後の課題
- 互換層の完全解消: レガシーフィールドから次世代`WeakBox`主導への移行を完了し、統一的な弱参照動作を保証する。
- 競合解決: 多重デリゲーション時のメソッド競合検出と診断の改良。
- 静的解析: 循環参照の静的検知・Lintの整備。
- エコシステム: P2P系Box、WASM環境APIの充実、`async/await`統合の高速化、数値/配列Boxの最適化。

## 9. 結論
Nyashは“Everything is Box”の統一モデルと、`init`/`fini`/`weak`/スコープ解放による予測可能で安全なメモリ管理を言語仕様として提示した。Rust実装により、所有権・スレッド安全・弱参照の自動nil化・二重解放防止を現実的コストで実現する。デリゲーション中心の設計は明示性を高め、教育・アート・Web・P2Pといった多様な開発領域での再利用性と保守性を支える。今後は互換層の収束と解析・最適化の強化により、研究用言語から実運用環境への移行を促進していく。

---

補足: 詳細は`docs/LANGUAGE_GUIDE.md`および`docs/reference/weak-reference-design.md`、実装は`src/`配下（`instance.rs`, `finalization.rs`, `interpreter/`）を参照。


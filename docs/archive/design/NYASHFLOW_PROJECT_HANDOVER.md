# ğŸ¨ NyashFlow ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå¼•ãç¶™ããƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

## ğŸ“… ä½œæˆæ—¥: 2025-01-09
## ğŸ‘¤ ä½œæˆè€…: Claude + ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆã«ã‚ƒã€œï¼‰

---

# ğŸŒŸ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

## ğŸ¯ NyashFlowã¨ã¯
**Nyashãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç’°å¢ƒ**
- ã€ŒEverything is Boxã€ã®å“²å­¦ã‚’è¦–è¦šçš„ã«è¡¨ç¾
- Boxã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã§ã¤ãªã’ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°
- æ•™è‚²çš„ä¾¡å€¤ã®é«˜ã„ãƒ„ãƒ¼ãƒ«ã‚’ç›®æŒ‡ã™

## ğŸš€ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®çµŒç·¯

### 1ï¸âƒ£ **å§‹ã¾ã‚Šï¼šeguiç ”ç©¶**
- Nyashã«GUIæ©Ÿèƒ½ï¼ˆEguiBoxï¼‰ã‚’å®Ÿè£…
- Windowsç‰ˆãƒ¡ãƒ¢å¸³ã€ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼é¢¨ã‚¢ãƒ—ãƒªã‚’ä½œæˆ
- BMPã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤ºã¾ã§æˆåŠŸ

### 2ï¸âƒ£ **ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¸ã®ç™ºå±•**
- eguiã®å¯èƒ½æ€§ã‚’æ¢ã‚‹ä¸­ã§ã€ãƒãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹UIã®æ§‹æƒ³ãŒç”Ÿã¾ã‚Œã‚‹
- ã€ŒEverything is Boxã€ã‚’è¦–è¦šåŒ–ã™ã‚‹ã‚¢ã‚¤ãƒ‡ã‚¢
- æ•™è‚²ç¾å ´ã§ã®æ´»ç”¨ã‚’æƒ³å®š

### 3ï¸âƒ£ **CharmFlow v5ã‹ã‚‰ã®å­¦ã³**
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä»¥å‰ä½œæˆã—ãŸå¤§è¦æ¨¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
- JavaScript + NyaMeshï¼ˆP2Pï¼‰ã§å®Ÿè£…
- **å¤±æ•—ã‹ã‚‰å­¦ã‚“ã ã“ã¨**ï¼š
  - ã‚«ãƒ—ã‚»ãƒ«åŒ–ã®æ¬ å¦‚ â†’ ã‚¹ãƒ‘ã‚²ãƒ†ã‚£ã‚³ãƒ¼ãƒ‰åŒ–
  - å½¹å‰²åˆ†æ‹…ã®ä¸æ˜ç¢º â†’ ä¿å®ˆå›°é›£
  - éå‰°ãªæ©Ÿèƒ½ â†’ è¤‡é›‘åŒ–

### 4ï¸âƒ£ **NyashFlowã®æ–¹å‘æ€§æ±ºå®š**
- Rust + WebAssemblyã§å®Ÿè£…
- Nyashã¨ã¯åˆ¥ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ç‹¬ç«‹
- ã‚·ãƒ³ãƒ—ãƒ«ã•ã‚’æœ€å„ªå…ˆ

---

# ğŸ—ï¸ æŠ€è¡“è¨­è¨ˆ

## ğŸ“ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### **åŸºæœ¬æ§‹æˆ**
```
nyashflow/
â”œâ”€â”€ Cargo.toml              # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs              # ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¨ãƒ³ãƒˆãƒª
â”‚   â”œâ”€â”€ main.rs             # ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç‰ˆã‚¨ãƒ³ãƒˆãƒª
â”‚   â”œâ”€â”€ visual/             # ğŸ¨ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«è¡¨ç¤ºå±¤
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ node_renderer.rs      # ãƒãƒ¼ãƒ‰æç”»
â”‚   â”‚   â”œâ”€â”€ connection_renderer.rs # æ¥ç¶šç·šæç”»
â”‚   â”‚   â””â”€â”€ canvas_manager.rs     # ã‚­ãƒ£ãƒ³ãƒã‚¹ç®¡ç†
â”‚   â”œâ”€â”€ execution/          # âš¡ å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³å±¤
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ interpreter_bridge.rs  # Nyashã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿é€£æº
â”‚   â”‚   â””â”€â”€ data_flow.rs          # ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ç®¡ç†
â”‚   â”œâ”€â”€ interaction/        # ğŸ–±ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå±¤
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ drag_drop.rs          # ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
â”‚   â”‚   â”œâ”€â”€ selection.rs          # é¸æŠå‡¦ç†
â”‚   â”‚   â””â”€â”€ context_menu.rs       # å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼
â”‚   â”œâ”€â”€ model/              # ğŸ“¦ ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å±¤
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ visual_node.rs        # ãƒãƒ¼ãƒ‰å®šç¾©
â”‚   â”‚   â”œâ”€â”€ connection.rs         # æ¥ç¶šå®šç¾©
â”‚   â”‚   â””â”€â”€ project.rs            # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
â”‚   â””â”€â”€ wasm/               # ğŸŒ WebAssemblyå±¤
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ bridge.rs             # JSé€£æº
â”œâ”€â”€ web/                    # ğŸŒ Webç”¨ãƒªã‚½ãƒ¼ã‚¹
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ style.css
â”‚   â””â”€â”€ pkg/                      # wasm-packå‡ºåŠ›
â””â”€â”€ examples/               # ğŸ“š ã‚µãƒ³ãƒ—ãƒ«
    â””â”€â”€ basic_flow.rs
```

### **è¨­è¨ˆåŸå‰‡**

#### 1. **å¾¹åº•çš„ãªã‚«ãƒ—ã‚»ãƒ«åŒ–**
```rust
pub struct VisualNode {
    // ğŸ”’ ã™ã¹ã¦ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ
    id: NodeId,
    node_type: BoxType,
    position: Pos2,
    #[serde(skip)]
    internal_state: NodeState,
}

impl VisualNode {
    // ğŸŒ å…¬é–‹APIã¯æœ€å°é™
    pub fn get_id(&self) -> NodeId { self.id }
    pub fn get_type(&self) -> &BoxType { &self.node_type }
    pub fn set_position(&mut self, pos: Pos2) { 
        // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ã
        if self.validate_position(pos) {
            self.position = pos;
        }
    }
}
```

#### 2. **æ˜ç¢ºãªè²¬ä»»åˆ†é›¢**
```rust
// âŒ æ‚ªã„ä¾‹ï¼ˆCharmFlowã®å¤±æ•—ï¼‰
impl EverythingManager {
    fn handle_everything(&mut self, event: Event) {
        // æç”»ã‚‚ã‚¤ãƒ™ãƒ³ãƒˆã‚‚å®Ÿè¡Œã‚‚å…¨éƒ¨...
    }
}

// âœ… è‰¯ã„ä¾‹ï¼ˆå˜ä¸€è²¬ä»»ï¼‰
impl NodeRenderer {
    pub fn render(&self, node: &VisualNode, ui: &mut Ui) {
        // æç”»ã ã‘ï¼
    }
}

impl DragDropHandler {
    pub fn handle_drag(&mut self, event: DragEvent) {
        // ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†ã ã‘ï¼
    }
}
```

#### 3. **ã‚³ãƒ¼ãƒ‰å“è³ªã®ç¶­æŒ**
- å„ãƒ•ã‚¡ã‚¤ãƒ«100è¡Œä»¥å†…ã‚’ç›®æ¨™
- é–¢æ•°ã¯30è¡Œä»¥å†…
- ãƒã‚¹ãƒˆã¯3éšå±¤ã¾ã§
- å¿…ãšãƒ†ã‚¹ãƒˆã‚’æ›¸ã

---

# ğŸ’» å®Ÿè£…è©³ç´°

## ğŸ¨ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒãƒ¼ãƒ‰ã‚·ã‚¹ãƒ†ãƒ 

### **ãƒãƒ¼ãƒ‰ã®ç¨®é¡ï¼ˆåˆæœŸå®Ÿè£…ï¼‰**
```rust
#[derive(Debug, Clone, PartialEq)]
pub enum BoxType {
    // åŸºæœ¬Box
    StringBox,
    IntegerBox,
    BoolBox,
    
    // æ“ä½œBox
    MathBox,
    ConsoleBox,
    
    // ã‚³ãƒ³ãƒ†ãƒŠBox
    ArrayBox,
}

impl BoxType {
    pub fn color(&self) -> Color32 {
        match self {
            BoxType::StringBox => Color32::from_rgb(100, 149, 237),
            BoxType::IntegerBox => Color32::from_rgb(144, 238, 144),
            BoxType::MathBox => Color32::from_rgb(255, 182, 193),
            // ...
        }
    }
    
    pub fn icon(&self) -> &str {
        match self {
            BoxType::StringBox => "ğŸ“",
            BoxType::IntegerBox => "ğŸ”¢",
            BoxType::MathBox => "ğŸ§®",
            // ...
        }
    }
}
```

### **æ¥ç¶šã‚·ã‚¹ãƒ†ãƒ **
```rust
pub struct Connection {
    id: ConnectionId,
    from_node: NodeId,
    from_port: PortId,
    to_node: NodeId,
    to_port: PortId,
}

pub struct Port {
    id: PortId,
    name: String,
    port_type: PortType,
    data_type: DataType,
}

#[derive(Debug, Clone, PartialEq)]
pub enum PortType {
    Input,
    Output,
}
```

## âš¡ å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³

### **Nyashã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿é€£æº**
```rust
use nyash::interpreter::{NyashInterpreter, NyashValue};

pub struct ExecutionEngine {
    interpreter: NyashInterpreter,
    node_mapping: HashMap<NodeId, String>, // NodeId â†’ Nyashå¤‰æ•°å
}

impl ExecutionEngine {
    pub fn execute_flow(&mut self, nodes: &[VisualNode], connections: &[Connection]) -> Result<(), ExecutionError> {
        // 1. ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆ
        let sorted_nodes = self.topological_sort(nodes, connections)?;
        
        // 2. Nyashã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
        let nyash_code = self.generate_nyash_code(&sorted_nodes, connections);
        
        // 3. å®Ÿè¡Œ
        self.interpreter.execute(&nyash_code)?;
        
        Ok(())
    }
}
```

## ğŸŒ WebAssemblyçµ±åˆ

### **WASM Bridge**
```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct NyashFlowApp {
    #[wasm_bindgen(skip)]
    nodes: Vec<VisualNode>,
    #[wasm_bindgen(skip)]
    connections: Vec<Connection>,
}

#[wasm_bindgen]
impl NyashFlowApp {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        console_error_panic_hook::set_once();
        Self {
            nodes: vec![],
            connections: vec![],
        }
    }
    
    pub fn add_node(&mut self, node_type: &str, x: f32, y: f32) -> u32 {
        // ãƒãƒ¼ãƒ‰è¿½åŠ å‡¦ç†
    }
    
    pub fn connect_nodes(&mut self, from_id: u32, to_id: u32) -> Result<(), JsValue> {
        // æ¥ç¶šå‡¦ç†
    }
    
    pub fn execute(&self) -> Result<String, JsValue> {
        // å®Ÿè¡Œå‡¦ç†
    }
}
```

---

# ğŸš€ é–‹ç™ºãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

## Phase 1: MVPï¼ˆ1-2é€±é–“ï¼‰
- [ ] åŸºæœ¬çš„ãªãƒãƒ¼ãƒ‰è¡¨ç¤º
- [ ] 3ç¨®é¡ã®Boxï¼ˆString, Integer, Consoleï¼‰
- [ ] ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒãƒ¼ãƒ‰ç§»å‹•
- [ ] æ¥ç¶šç·šã®è¡¨ç¤º
- [ ] ç°¡å˜ãªå®Ÿè¡Œï¼ˆConsoleBoxã§printï¼‰

## Phase 2: åŸºæœ¬æ©Ÿèƒ½ï¼ˆ2-3é€±é–“ï¼‰
- [ ] å…¨åŸºæœ¬Boxã‚¿ã‚¤ãƒ—å®Ÿè£…
- [ ] æ¥ç¶šã®ä½œæˆ/å‰Šé™¤
- [ ] å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼
- [ ] ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜/èª­ã¿è¾¼ã¿ï¼ˆJSONï¼‰
- [ ] å®Ÿè¡Œçµæœã®è¡¨ç¤º

## Phase 3: WebAssemblyå¯¾å¿œï¼ˆ2é€±é–“ï¼‰
- [ ] wasm-packè¨­å®š
- [ ] Webç”¨UIèª¿æ•´
- [ ] ãƒ–ãƒ©ã‚¦ã‚¶ã§ã®å‹•ä½œç¢ºèª
- [ ] GitHubPageså…¬é–‹

## Phase 4: é«˜åº¦ãªæ©Ÿèƒ½ï¼ˆ1ãƒ¶æœˆï¼‰
- [ ] ã‚«ã‚¹ã‚¿ãƒ Boxä½œæˆ
- [ ] ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ï¼ˆã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œï¼‰
- [ ] ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼å¯è¦–åŒ–ï¼‰
- [ ] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ©Ÿèƒ½

---

# ğŸ“ å®Ÿè£…ä¸Šã®æ³¨æ„ç‚¹

## âš ï¸ CharmFlowã®å¤±æ•—ã‚’é¿ã‘ã‚‹

### 1. **éå‰°ãªæ©Ÿèƒ½ã‚’é¿ã‘ã‚‹**
- P2Pé€šä¿¡ â†’ ä¸è¦
- ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ  â†’ Phase 4ä»¥é™
- è¤‡é›‘ãªIntent â†’ ç›´æ¥çš„ãªãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

### 2. **ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒã‚¤ãƒ³ãƒˆ**
```rust
// æ¯å›ãƒã‚§ãƒƒã‚¯
- [ ] ãƒ•ã‚¡ã‚¤ãƒ«ãŒ100è¡Œã‚’è¶…ãˆã¦ã„ãªã„ã‹ï¼Ÿ
- [ ] é–¢æ•°ãŒ30è¡Œã‚’è¶…ãˆã¦ã„ãªã„ã‹ï¼Ÿ
- [ ] Private Fieldsã‚’ä½¿ã£ã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] è²¬ä»»ãŒå˜ä¸€ã‹ï¼Ÿ
- [ ] ãƒ†ã‚¹ãƒˆã‚’æ›¸ã„ãŸã‹ï¼Ÿ
```

### 3. **å®šæœŸçš„ãªãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°**
- é€±1å›ã¯ã‚³ãƒ¼ãƒ‰å…¨ä½“ã‚’è¦‹ç›´ã™
- é‡è¤‡ã‚’è¦‹ã¤ã‘ãŸã‚‰å³åº§ã«çµ±åˆ
- è¤‡é›‘ã«ãªã£ãŸã‚‰åˆ†å‰²

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_node_creation() {
        let node = VisualNode::new(BoxType::StringBox, Pos2::new(100.0, 100.0));
        assert_eq!(node.get_type(), &BoxType::StringBox);
    }
    
    #[test]
    fn test_connection_validation() {
        // StringBox â†’ ConsoleBoxã¯æ¥ç¶šå¯èƒ½
        assert!(Connection::can_connect(
            &BoxType::StringBox, 
            &PortType::Output,
            &BoxType::ConsoleBox, 
            &PortType::Input
        ));
    }
}
```

---

# ğŸ¯ æˆåŠŸã®æŒ‡æ¨™

## å®šé‡çš„æŒ‡æ¨™
- ã‚³ãƒ¼ãƒ‰è¡Œæ•°ï¼š5,000è¡Œä»¥å†…ï¼ˆCharmFlowã®1/10ï¼‰
- ãƒ•ã‚¡ã‚¤ãƒ«æ•°ï¼š50å€‹ä»¥å†…
- ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ï¼š80%ä»¥ä¸Š
- èµ·å‹•æ™‚é–“ï¼š1ç§’ä»¥å†…

## å®šæ€§çš„æŒ‡æ¨™
- å°å­¦ç”Ÿã§ã‚‚ä½¿ãˆã‚‹ç›´æ„Ÿæ€§
- Nyashã®å“²å­¦ãŒä¼ã‚ã‚‹
- ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ãŒè‹¦ã«ãªã‚‰ãªã„
- æ‹¡å¼µãŒå®¹æ˜“

---

# ğŸ”— å‚è€ƒè³‡æ–™

## æŠ€è¡“è³‡æ–™
- [eguiå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.rs/egui)
- [wasm-bindgen book](https://rustwasm.github.io/wasm-bindgen/)
- [Nyashãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ](../../../README.md)

## è¨­è¨ˆæ€æƒ³
- CharmFlow v5ã®çµŒé¨“ï¼ˆåé¢æ•™å¸«ï¼‰
- ã€ŒEverything is Boxã€å“²å­¦
- ã‚·ãƒ³ãƒ—ãƒ«ãƒ»ã‚¤ã‚ºãƒ»ãƒ™ã‚¹ãƒˆ

## é¡ä¼¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
- Scratchï¼ˆæ•™è‚²çš„UIï¼‰
- Node-REDï¼ˆãƒ•ãƒ­ãƒ¼ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ï¼‰
- Unreal Engine Blueprintï¼ˆã‚²ãƒ¼ãƒ å‘ã‘ï¼‰

---

# ğŸ’¬ æœ€å¾Œã«

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’è¦–è¦šçš„ã«ç†è§£ã™ã‚‹ã€ã¨ã„ã†å¤¢ã‚’å®Ÿç¾ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

CharmFlowã®å¤±æ•—ã‹ã‚‰å­¦ã³ã€Nyashã®å“²å­¦ã‚’æ´»ã‹ã—ã€ã‚·ãƒ³ãƒ—ãƒ«ã§ç¾ã—ã„ãƒ„ãƒ¼ãƒ«ã‚’ä½œã‚Šã¾ã—ã‚‡ã†ã€‚

**ã€ŒEverything is Boxã€ãŒã€ŒEverything is Visible Boxã€ã«ãªã‚‹ç¬é–“ã‚’æ¥½ã—ã¿ã«ã—ã¦ã„ã¾ã™ï¼**

ã«ã‚ƒã€œğŸ¨âœ¨

---

# ğŸ”® P2PBox/intentboxè¨­è¨ˆã®æ´»ç”¨ï¼ˆ2025-01-09è¿½è¨˜ï¼‰

## ğŸ¯ NyaMeshè¨­è¨ˆã‹ã‚‰å­¦ã¶ã“ã¨

### **æ ¸å¿ƒæ¦‚å¿µã®æŠ½å‡º**

NyaMeshã®`P2PBox`ã¨`intentbox`ã‹ã‚‰ã€NyashFlowã«æ´»ç”¨ã§ãã‚‹**æœ¬è³ªçš„ãªè¨­è¨ˆæ€æƒ³**ï¼š

1. **intentbox = é€šä¿¡ä¸–ç•Œã®å®šç¾©**
   - ãƒ—ãƒ­ã‚»ã‚¹å†…ã€WebSocketã€ãƒ¡ãƒ¢ãƒªå…±æœ‰ãªã©
   - é€šä¿¡ã®ã€Œå ´ã€ã‚’æŠ½è±¡åŒ–

2. **P2PBox = ãã®ä¸–ç•Œã«å‚åŠ ã™ã‚‹ãƒãƒ¼ãƒ‰**
   - ã©ã®intentboxã«æ‰€å±ã™ã‚‹ã‹ã§é€šä¿¡ç›¸æ‰‹ãŒæ±ºã¾ã‚‹
   - ã‚·ãƒ³ãƒ—ãƒ«ãªsend/onã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

### **NyashFlowã¸ã®å¿œç”¨ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰**

```rust
// âš¡ ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ï¼ˆPhase 1-2ï¼‰
pub struct LocalExecutionContext {
    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒãƒ¼ãƒ‰é–“ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ç®¡ç†
    data_bus: DataFlowBus,
}

// ğŸŒ å°†æ¥ã®æ‹¡å¼µï¼ˆPhase 4ä»¥é™ï¼‰
pub trait ExecutionContext {
    fn send_data(&mut self, from: NodeId, to: NodeId, data: NyashValue);
    fn on_data(&mut self, node: NodeId, callback: DataCallback);
}

// ç•°ãªã‚‹å®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å®Ÿè£…ä¾‹
impl ExecutionContext for LocalExecutionContext { ... }
impl ExecutionContext for RemoteExecutionContext { ... }  // WebSocketçµŒç”±
impl ExecutionContext for SharedMemoryContext { ... }     // é«˜é€Ÿå…±æœ‰ãƒ¡ãƒ¢ãƒª
```

### **æ®µéšçš„ãªå°å…¥è¨ˆç”»**

#### Phase 1-2: ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼
```rust
// æœ€åˆã¯ã‚·ãƒ³ãƒ—ãƒ«ã«
pub struct DataFlowEngine {
    nodes: HashMap<NodeId, VisualNode>,
    connections: Vec<Connection>,
}

impl DataFlowEngine {
    pub fn execute(&mut self) {
        // å˜ç´”ãªåŒæœŸå®Ÿè¡Œ
        for connection in &self.connections {
            let data = self.get_output_data(connection.from_node);
            self.set_input_data(connection.to_node, data);
        }
    }
}
```

#### Phase 3-4: æŠ½è±¡åŒ–ã•ã‚ŒãŸå®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
```rust
// P2PBoxçš„ãªæŠ½è±¡åŒ–ã‚’å°å…¥
pub struct VisualNodeBox {
    id: NodeId,
    context: Box<dyn ExecutionContext>,  // ã©ã®ã€Œä¸–ç•Œã€ã§å®Ÿè¡Œã™ã‚‹ã‹
}

impl VisualNodeBox {
    pub fn send(&self, data: NyashValue, to: NodeId) {
        self.context.send_data(self.id, to, data);
    }
    
    pub fn on_receive<F>(&mut self, callback: F) 
    where F: Fn(NyashValue) + 'static {
        self.context.on_data(self.id, Box::new(callback));
    }
}
```

### **å®Ÿç”¨çš„ãªå¿œç”¨ä¾‹**

#### 1. **ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰å®Ÿè¡Œï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰**
```rust
// é‡ã„å‡¦ç†ã‚’åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§
let math_context = ThreadedExecutionContext::new();
let math_node = VisualNodeBox::new(BoxType::MathBox, math_context);
```

#### 2. **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚³ãƒ©ãƒœãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå°†æ¥ï¼‰**
```rust
// WebSocketã§ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨å…±æœ‰
let collab_context = WebSocketContext::new("wss://nyashflow.example.com");
let shared_node = VisualNodeBox::new(BoxType::SharedBox, collab_context);
```

#### 3. **ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰**
```rust
// ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã‚’è¨˜éŒ²
let debug_context = RecordingContext::new();
// å¾Œã§ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã‚’å†ç”Ÿãƒ»åˆ†æå¯èƒ½
```

### **è¨­è¨ˆä¸Šã®é‡è¦ãªåˆ¤æ–­**

1. **æœ€åˆã¯ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œã®ã¿**
   - P2Pæ©Ÿèƒ½ã¯ä½œã‚‰ãªã„ï¼ˆCharmFlowã®æ•™è¨“ï¼‰
   - ã§ã‚‚å°†æ¥ã®æ‹¡å¼µæ€§ã¯ç¢ºä¿

2. **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®çµ±ä¸€**
   - send/onã®ã‚·ãƒ³ãƒ—ãƒ«ãªAPIã‚’ç¶­æŒ
   - å®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯éš è”½

3. **æ®µéšçš„ãªè¤‡é›‘æ€§**
   - Phase 1-2: åŒæœŸçš„ãªãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œ
   - Phase 3: éåŒæœŸå®Ÿè¡Œå¯¾å¿œ
   - Phase 4: ãƒªãƒ¢ãƒ¼ãƒˆå®Ÿè¡Œï¼ˆå¿…è¦ãªã‚‰ï¼‰

### **å®Ÿè£…ã®æŒ‡é‡**

```rust
// âŒ é¿ã‘ã‚‹ã¹ãå®Ÿè£…ï¼ˆCharmFlowçš„ï¼‰
struct EverythingNode {
    p2p_manager: P2PManager,
    intent_bus: IntentBus,
    websocket: WebSocket,
    // ... 100å€‹ã®æ©Ÿèƒ½
}

// âœ… æ¨å¥¨ã•ã‚Œã‚‹å®Ÿè£…ï¼ˆNyashFlowçš„ï¼‰
struct VisualNode {
    data: NodeData,
    // å®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯å¤–éƒ¨ã‹ã‚‰æ³¨å…¥
}

struct ExecutionEngine {
    context: Box<dyn ExecutionContext>,
    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å·®ã—æ›¿ãˆå¯èƒ½
}
```

### **ã¾ã¨ã‚ï¼šã€Œã„ã„ã¨ã“å–ã‚Šã€ã®ç²¾ç¥**

- **P2PBox/intentboxã®å„ªã‚ŒãŸæŠ½è±¡åŒ–**ã‚’å‚è€ƒã«
- **æœ€åˆã¯ã‚·ãƒ³ãƒ—ãƒ«ã«**å®Ÿè£…
- **å°†æ¥ã®æ‹¡å¼µæ€§**ã‚’è¨­è¨ˆã«çµ„ã¿è¾¼ã‚€
- **éå‰°ãªæ©Ÿèƒ½ã¯é¿ã‘ã‚‹**

ã“ã‚Œã«ã‚ˆã‚Šã€NyashFlowã¯ï¼š
- åˆæœŸã¯å˜ç´”ãªãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç’°å¢ƒ
- å¿…è¦ã«å¿œã˜ã¦é«˜åº¦ãªå®Ÿè¡Œãƒ¢ãƒ‡ãƒ«ã«æ‹¡å¼µå¯èƒ½
- CharmFlowã®å¤±æ•—ã‚’ç¹°ã‚Šè¿”ã•ãªã„

---

## ğŸ“‹ ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆï¼ˆé–‹ç™ºé–‹å§‹æ™‚ï¼‰

- [ ] ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’èª­ã¿çµ‚ãˆãŸ
- [ ] Nyashãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ“ãƒ«ãƒ‰ã§ãã‚‹
- [ ] eguiã®ã‚µãƒ³ãƒ—ãƒ«ã‚’å‹•ã‹ã—ãŸ
- [ ] ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆã—ãŸ
- [ ] æœ€åˆã®ã‚³ãƒŸãƒƒãƒˆã‚’ã—ãŸ

é ‘å¼µã£ã¦ã«ã‚ƒã€œï¼ğŸš€
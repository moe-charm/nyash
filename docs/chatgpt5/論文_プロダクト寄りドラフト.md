# Nyash: 実務志向の一貫メモリモデルで日常のプログラミングを簡潔に

最終更新: 2025-08-13（プロダクト寄りドラフト）

## 概要（Abstract）
Nyashは、すべての値を「Box」に統一し、`init`/`fini`/`weak`/スコープ解放を言語構文に組み込むことで、日常的なメモリ管理をわかりやすくする実務志向の言語です。新奇なアルゴリズムを主張するものではなく、過去数十年のプラクティス（RAII、弱参照、明示的ライフサイクル）を「最初から言語仕様で一貫させる」ことで、予測可能で安全なプログラミング体験を提供します。Rust実装により所有権とスレッド安全を担保しながら、再代入・スコープ終了・循環参照といった“よくある落とし穴”を構文で回避します。

## 1. 課題設定（なにを楽にするか）
- 「いつ解放されるのか」がコードから読み取りづらい（暗黙のGC/規約依存）。
- 双方向参照やグラフ構造でリークしやすい（参照カウントの残留）。
- フィールド/ローカル/グローバルの寿命や責務が曖昧になりがち。

## 2. Nyashの要点（どう簡単にするか）
- 統一モデル: Everything is Box。生成・代入・比較・解放の扱いが一貫。
- 明示宣言: `init { ... }`でフィールド列挙、循環は`weak`で明示。
- 予備解放: 再代入・スコープ終了・明示呼出しで`fini()`が走る規約。
- ローカル変数: `local`を必須化し、未宣言代入エラーで早期検知。
- デリゲーション: `from`で機能合成（多重対応）。`override`は明示必須。

## 3. なにが“新しい”のではなく“役立つ”のか（ポジショニング）
- 研究的な新規性よりも、既知の良い手法の言語レベル統合に価値。
- 「60年のメモリ管理の知見を、日常利用に迷わない形へ整理」
- 開発者体験（DX）と運用の予測可能性（いつ・どこで解放）が主眼。

## 4. 開発者にとっての具体的メリット
- リーク/二重解放の抑止: `fini()`は二重防止付き、弱参照は自動nil化。
- 可読性: フィールド寿命・弱参照・委譲関係がコードから一目で分かる。
- テスト容易性: 多重デリゲーションで依存差し替えが明瞭。
- ブラウザ対応: WASMで“動かして学ぶ”導線が短い。

## 5. 最小構文サンプル
```nyash
box Parent { init { child } }
box Child  { init { weak parent } }

p = new Parent()
p.child = new Child()
p.child.setParent(p)      # 子→親はweak。循環でもリークしにくい

box Holder { init { obj } }
h = new Holder()
h.obj = new SomeBox()
h.obj = new SomeBox()     # 旧objに対しfini()が自動呼出し

static box Main { main() { print("OK") } }
```

## 6. 実装概要（Rust）
- 実行時値: `NyashValue`に`Box(Arc<Mutex<_>>)`と`WeakBox(Weak<Mutex<_>>)`を持ち、弱参照はアクセス時upgrade→失敗で`null`。
- インスタンス: `InstanceBox`が`set_weak_field`/`get_weak_field`で弱参照の格納・自動nil化を扱う。`fini()`は二重防止付き。
- スコープ解放: `finalization`モジュールの`BoxFinalizer`がスコープ終了時に一括予備解放。
- 代入時処理: フィールド再代入前に旧値へ`fini()`。安全側に倒す規約。

## 7. 非ゴール（誤解を避けるために）
- 新規GCの提案ではない。停止時間最適化などGC起因の研究課題は対象外。
- 低レベル最適化の網羅ではない。まずは実務的に“迷わない統一手引き”。

## 8. 導入・評価の観点（プロダクト視点）
- DX: 未宣言代入の早期検知、解放点の明示、弱参照のシンプル化がバグ件数/修正時間に与える影響。
- 安定運用: リーク/ダングリング参照/二重解放の再現テストと回避率。
- 性能: 弱参照upgrade/`fini()`呼出しのオーバーヘッド（マイクロ/アプリ）。
- 学習曲線: Web/WASMのプレイグラウンドでの到達時間・課題種別。

## 9. 現状とロードマップ
- 現状: インタープリタ、弱参照の自動nil化、再代入時`fini()`、多重デリゲーションの基盤が稼働。
- 近接課題: レガシー互換層の整理、競合検出メッセージの改善、P2P/標準Boxの拡充。

## 10. まとめ
Nyashは“新しい理論”よりも“迷わない実装規約”で、日常のメモリ管理を静かに楽にすることを狙う。Boxの統一モデルと、`init`/`fini`/`weak`/スコープ解放の一貫性により、解放のタイミングがコードから読める。弱参照の自動nil化と二重解放防止は、実務の落とし穴を減らす。WASM対応の軽い体験とRust実装の堅牢さを両輪に、まずは「使って心地よい」ことを優先し、順次、解析・最適化・エコシステムを整えていく。

— 参考: 詳細は `docs/LANGUAGE_GUIDE.md`, `docs/reference/weak-reference-design.md` と `src/` 実装を参照。

## 付録: ブラウザデモ活用（再現性と導線）
- Playground: https://moe-charm.github.io/nyash/projects/nyash-wasm/nyash_playground.html
- ガイド: プレイグラウンド_ガイド.md（シナリオと手順）
- サンプル集: プレイグラウンド_サンプル.md（コピー＆ペースト用）

活用ポイント:
- `init`/`fini`/`weak`/スコープ解放の最小例を即時実行し、期待ログ（例: `Thing.fini`、`parent is gone`）で確認可能。
- レビュワー/読者はゼロインストールで再現でき、arXiv原稿への短縮URL/QR掲載と相性が良い。
- 比較検証（weakなし/あり、再代入前後、スコープ内/外）を1ページで切替・確認可能。
